\documentclass[11pt]{article}
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 21.94cm 
%\pagestyle{empty}       % Uncomment if don't want page numbers
\parskip 7.2pt           % sets spacing between paragraphs
%\renewcommand{\baselinestretch}{1.5} % Uncomment for 1.5 spacing between lines
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{verbatim}
\parindent 0pt		 % sets leading space for paragraphs
\author{Erik Waingarten, Matt Susskind, Fermi Ma}
\title{Ghost}


\begin{document}         
\maketitle

\section{Game}

Given a language, two people alternate picking letters such that the sequence is the prefix of a word in that language. If the sequence ever spells a valid word, the one who said the final letter loses. If at any point the current player doesn't believe there is a word that can be spelled with the current sequence, they can challenge the other player to produce a valid word.

\section{Generalization}

We assume that the language is given by a regular expression. People always spell sequences that are prefixes of a word in the language.

The question here is: Given a regular language, does player 1 have a winning strategy?

\section{PSPACE-hard reduction}

The reduction is from directed vertex Geography. Suppose we have a directed graph $G$ with starting node $s$. We will build an NFA that will give a regular expression to play Ghost with. We will build the NFA using the graph $G$. First, we label all the edges of $G$ arbritrarily. These will represent transitions in the NFA. 

For each node, $x \in G$, suppose $x$ has some outgoing edge. We make another copy of the graph $G$, called $G_x$. This graph has the same edge labels as the general $G$. If $x$ has a directed edge with another node $a$ with label $l$, then we will make a transition from $x$ to $a' \in G_x$ with transition $l$. We do this for each neighbor of $x$, $a$. Additionally, we make $x' \in G_x$ an accept state. 

If $x \in G$ has no outgoing edges, then $x$ in the NFA will have a transition to an accept state $y$ with all the labels.

From this NFA, we can make a regular expression in polynomial time.

Each time a player makes a move in Generalized Geography, the edge will correspond to a label in the NFA. If we follow the computation of the NFA, we will travel to the next edge. If any player reaches a node with no outgoing edges in Generalized Geography, then this corresponds to a state in the NFA that is connected to an accepting state by all the labels. Then, no matter what the next person says, he loses, since he ends up in an accept state in the NFA, and so that word was part of the language.

Suppose a player makes a move to an edge that does have outgoing edges. We follow the computation on the regular NFA. At the same time, we transition to the copy of the graph that tests whether we ever return to that node. Since that node is an accept state, we want to avoid returning, otherwise we lose. This is the right thing to do since in generalized geography, we removed the vertex from the graph. 

\section{Ghost is in PSPACE}

Each game of ghost can be thought of as a string of moves, each string is polynomially long, so we can do an NPSPACE search of all games that player 2 wins no matter what player 1 plays. If there is any such game, then accept. So we can determine whether there is no winning strategy for player 1 in NPSPACE. Since PSPACE = NPSPACE = co-PSPACE, so we can solve Ghost in PSPACE. 

\section{Ghost is PSPACE-hard in German}

So now we make a slight modification to show that the reduction only requires playing Ghost in the German language. The new formultion of the game is as follows:

Instance: There is a subset of words in the German language that is compressed in some manner. (in our case, using a regular expression to compress it will be enough)\\
Question: If player 1 starts, is there a winning strategy for player 1? 

We are using the German language because in German, it is grammatically correct to concatenate an arbritrary number of nouns by putting a hyphen between them. Also, we are saying that the subset of words shouldbe compressed, because if the input is just the subset of words, then we can always build a game tree and run a minimax algorithm to solve it in polynomial time. The problem becomes interesting when the compressed version of length $n$ can represent exponentially many words in the subset. 

We can analyze the reduction to regular expressions and note a couple things:

First, there are finitely many words in the language generated by the regular expression. This is good, since it means that the regular expression is only comprised of concatenations and unions, and there are no $*$ operators. 

Second, we could have done the same reduction with Generalized Geography played in planar graphs, since this is still PSPACE-complete. And when we played in the planar graph, we could have colored the graph with 5 colors in polynomial time since a planar graph is isomorphic to a map, where edges correspond to adjacency. 

So now, we could have labeled the edges of the Generalized Geography game by the color of the vertex that the edge points to. This would also translate to the NFA in the transitions. Now we are almost done. 

Note that each transition will be a color, and there will be five colors, so we just need to map each of the five colors to a noun in the German language. Also, the once one of the words is started, it must finish that word, which will correspond to following that transition. Since the concatenation must end with a hyphen, we want to look for five nouns in the German language that start with different letters and each have even length, then the person who began the word will say the hyphen, and that would complete the transition to the next state in the NFA. 

NEED TO FIND EVEN LEGNTH WORDS!

The following five nouns work: ``wort'' (word), ``band'' (bond), ``teil'' (piece), ``see'' (lake), and ``all'' (universe). 

Then the subset of words might look something like:
\[ \{ \text{see-all}, \text{wort-band-teil}, \text{see-teil-wort}, ... \} \]
which can be generated by the following regular expression:
\[ (\{\text{see} \}\cup \{ \text{wort}\})(\{\text{-all} \} \cup \{\text{-band}\} \cup \{ \text{-teil} \})( \{ \epsilon\} \cup \{ \text{-teil} \} \cup \{\text{-wort} \}) \]

\end{document}
